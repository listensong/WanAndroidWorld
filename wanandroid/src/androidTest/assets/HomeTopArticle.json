{
  "data": [
    {
      "apkLink": "",
      "audit": 1,
      "author": "扔物线",
      "canEdit": false,
      "chapterId": 249,
      "chapterName": "干货资源",
      "collect": false,
      "courseId": 13,
      "desc": "",
      "descMd": "",
      "envelopePic": "",
      "fresh": true,
      "id": 12554,
      "link": "https://mp.weixin.qq.com/s/CFWznkSrq6JmW1fZdqdlOg",
      "niceDate": "刚刚",
      "niceShareDate": "2020-03-23 16:36",
      "origin": "",
      "prefix": "",
      "projectLink": "",
      "publishTime": 1587657600000,
      "selfVisible": 0,
      "shareDate": 1584952597000,
      "shareUser": "",
      "superChapterId": 249,
      "superChapterName": "干货资源",
      "tags": [],
      "title": "【扔物线】消失了半年，这个 Android 界的第一骚货终于回来了",
      "type": 1,
      "userId": -1,
      "visible": 1,
      "zan": 0
    },
    {
      "apkLink": "",
      "audit": 1,
      "author": "",
      "canEdit": false,
      "chapterId": 86,
      "chapterName": "图片处理",
      "collect": false,
      "courseId": 13,
      "desc": "",
      "descMd": "",
      "envelopePic": "",
      "fresh": true,
      "id": 12693,
      "link": "https://www.jianshu.com/p/878e4ddaa51b",
      "niceDate": "刚刚",
      "niceShareDate": "2020-03-31 23:20",
      "origin": "",
      "prefix": "",
      "projectLink": "",
      "publishTime": 1587312000000,
      "selfVisible": 0,
      "shareDate": 1585668046000,
      "shareUser": "adyeah",
      "superChapterId": 87,
      "superChapterName": "图片加载",
      "tags": [],
      "title": "如何加载100M的图片却不撑爆内存,一张 100M 的大图，如何预防 OOM？",
      "type": 1,
      "userId": 56231,
      "visible": 1,
      "zan": 0
    },
    {
      "apkLink": "",
      "audit": 1,
      "author": "xiaoyang",
      "canEdit": false,
      "chapterId": 440,
      "chapterName": "官方",
      "collect": false,
      "courseId": 13,
      "desc": "<pre><code>android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.\r\n        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:8066)\r\n        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1297)\r\n        at android.view.View.requestLayout(View.java:23147)\r\n        at android.view.View.requestLayout(View.java:23147)\r\n</code></pre><p>相信大家都见过这样的错误，而且拍大腿都知道，这个问题肯定是更新控件不在UI线程导致的。</p>\r\n<p>你肯定有各种方式来解决。</p>\r\n<p>但是我们今天就要问点你怀疑人生的问题：</p>\r\n<ol>\r\n<li>真的只有UI线程才能更新界面UI吗？</li>\r\n<li>UI 线程更新界面UI有可能报上述错误吗？</li>\r\n<li>请举例说明...</li>\r\n<li>最好能附带源码解析。</li>\r\n</ol>",
      "descMd": "",
      "envelopePic": "",
      "fresh": true,
      "id": 12922,
      "link": "https://wanandroid.com/wenda/show/12922",
      "niceDate": "16小时前",
      "niceShareDate": "16小时前",
      "origin": "",
      "prefix": "",
      "projectLink": "",
      "publishTime": 1587143943000,
      "selfVisible": 0,
      "shareDate": 1587143623000,
      "shareUser": "",
      "superChapterId": 440,
      "superChapterName": "问答",
      "tags": [
        {
          "name": "本站发布",
          "url": "/article/list/0?cid=440"
        },
        {
          "name": "问答",
          "url": "/wenda"
        }
      ],
      "title": "每日一问 | &ldquo;必须在UI线程才能更新控件/界面&rdquo;  这句人人皆知的话，100%正确吗？",
      "type": 1,
      "userId": 2,
      "visible": 1,
      "zan": 0
    },
    {
      "apkLink": "",
      "audit": 1,
      "author": "xiaoyang",
      "canEdit": false,
      "chapterId": 440,
      "chapterName": "官方",
      "collect": false,
      "courseId": 13,
      "desc": "<p>很多时候，为了保证整体app的页面切换动画统一，我们都会为每个Activity页面设置统一的退出和进入动画。</p>\r\n<p>那么动画是要设置duration的，问题来了：</p>\r\n<ol>\r\n<li>设置页面切换动画对页面打开速度有影响吗？</li>\r\n<li>这个duration设置多少合适呢？系统默认有值吗？</li>\r\n</ol>",
      "descMd": "",
      "envelopePic": "",
      "fresh": false,
      "id": 12502,
      "link": "https://wanandroid.com/wenda/show/12502",
      "niceDate": "2020-04-13 23:57",
      "niceShareDate": "2020-03-20 19:59",
      "origin": "",
      "prefix": "",
      "projectLink": "",
      "publishTime": 1586793455000,
      "selfVisible": 0,
      "shareDate": 1584705540000,
      "shareUser": "",
      "superChapterId": 440,
      "superChapterName": "问答",
      "tags": [
        {
          "name": "本站发布",
          "url": "/article/list/0?cid=440"
        },
        {
          "name": "问答",
          "url": "/wenda"
        }
      ],
      "title": "每日一问 | Activity 启动动画对页面打开速度有影响吗？",
      "type": 1,
      "userId": 2,
      "visible": 1,
      "zan": 0
    },
    {
      "apkLink": "",
      "audit": 1,
      "author": "xiaoyang",
      "canEdit": false,
      "chapterId": 440,
      "chapterName": "官方",
      "collect": false,
      "courseId": 13,
      "desc": "<p>看过LifeCycle源码的同学可能都能说出来：</p>\r\n<p>LifeCycle 利用 Fragment，进行 Event 分发，然后通过反射执行各个 LifecycleObserver 中对应的Event 注册方法。</p>\r\n<p>其中还引入了一个 State 的概念，那么为什么不 Fragment dispatch Event的时候直接执行到 Observer 里面的相关事件方法， 而要经过一个 State 的概念呢？</p>\n\n<p>参考入口，类名：ReportFragment</p>\n\r\n<pre><code>#ReportFragment\r\n@Override\r\npublic void onActivityCreated(Bundle savedInstanceState) {\r\n     super.onActivityCreated(savedInstanceState);\r\n     dispatchCreate(mProcessListener);\r\n     dispatch(Lifecycle.Event.ON_CREATE);\r\n}\r\n</code></pre>",
      "descMd": "",
      "envelopePic": "",
      "fresh": false,
      "id": 12230,
      "link": "https://wanandroid.com/wenda/show/12230",
      "niceDate": "2020-04-09 23:51",
      "niceShareDate": "2020-03-07 22:26",
      "origin": "",
      "prefix": "",
      "projectLink": "",
      "publishTime": 1586447475000,
      "selfVisible": 0,
      "shareDate": 1583591166000,
      "shareUser": "",
      "superChapterId": 440,
      "superChapterName": "问答",
      "tags": [
        {
          "name": "本站发布",
          "url": "/article/list/0?cid=440"
        },
        {
          "name": "问答",
          "url": "/wenda"
        }
      ],
      "title": "每日一问 LifeCycle 对于 Lifecycle.Event 为啥不直接分发，而是通过 Lifecycle.State 中转？",
      "type": 1,
      "userId": 2,
      "visible": 1,
      "zan": 1
    }
  ],
  "errorCode": 0,
  "errorMsg": ""
}